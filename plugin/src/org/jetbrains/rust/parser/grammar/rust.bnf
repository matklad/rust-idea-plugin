{
  parserClass="org.jetbrains.rust.grammar.RustParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Rust"
  psiImplClassSuffix="Impl"
  psiPackage="org.jetbrains.rust.psi"
  psiImplPackage="org.jetbrains.rust.psi.impl"

  elementTypeHolderClass="org.jetbrains.rust.psi.RustTypes"
  elementTypeClass="org.jetbrains.rust.psi.RustElementType"
  tokenTypeClass="org.jetbrains.rust.parser.RustTokenType"

  tokens=[
    par_left            = "("
    par_right           = ")"
    curly_left          = "{"
    curly_right         = "}"
    bracket_left        = "["
    bracket_right       = "]"
    pipe                = "|"
    pipe_pipe           = "||"
    ampersand           = "&"
    ampersand_ampersand = "&&"
    dot                 = "."
    dot_dot             = ".."
    dot_dot_dot         = "..."
    semi                = ";"
    comma               = ","
    bang                = "!"
    colon               = ":"
    assign              = "="
    minus               = "-"
    plus                = "+"
    less_equal          = "<="
    greater_equal       = ">="

    less                = "<"
    greater             = ">"


    white_space='regexp:\s+'
    line_comment='regexp://.*'
    block_comment='regexp:/\*(.|\n)*\*/'
    ident='regexp:(\p{Alpha}|_)*'

    lit_char="regexp:'.'"
    lit_string="regexp:(r?\"([^\"\\]|\\.)*\")"
    lit_byte_string='byte_string_lit'
    lit_float='regexp:\d+\.\d+'
    lit_byte='byte_lit'
    lit_integer='regexp:\d+'
    lit_bool='regexp:true|false'
  ]

   extends(".*expr")=expr
}

////////////////////////////////////////////////////////////////////////
// Part 1: Items and attributes
////////////////////////////////////////////////////////////////////////

rustFile ::= inner_attr* item_with_attrs *

inner_attr ::= '#!' '[' meta_item ']'

outer_attrs ::= outer_attr *

outer_attr ::= '#' '[' meta_item ']'

meta_item ::= ident '=' lit
            | ident '(' <<comma_separated_list meta_item>> ')'
            | ident

item_with_attrs ::= attrs_and_vis item

attrs_and_vis ::= outer_attrs [visibility]

// items that can appear outside of a fn block
private item ::= stmt_item
               | use_item
               | extern_crate_item


extern_crate_item ::= extern crate ident [as ident] ';'
use_item ::= use path_glob ';'

path_glob ::= ident ["::" (path_glob | "*")]
            | '{' [<<comma_separated_list path_item>>] '}'

path_item ::= ident | self

// items that can appear in "stmts"
private stmt_item ::= static_item
                    | const_item
                    | block_item

static_item ::= static [mut] ident ':' ty '=' expr ';'

const_item ::= const ident ':' ty '=' expr ';'

private block_item ::= fn_item | mod_item | struct_item | impl_item


visibility ::= pub

fn_item ::= fn ident [generic_params] fn_params [ret_ty] [where_clause] block_expr

private fn_params ::= '(' [ <<comma_separated_list fn_param>> ] ')'

fn_param ::= pat ':' ty_sum

private ret_ty ::= '->' ('!' | ty)

generic_params ::= '<' [lifetimes]  <<comma_separated_list ty_param>> '>'

where_clause ::= where

mod_item ::= mod ident ['{' inner_attr* item_with_attrs* '}']';'

struct_item ::= struct ident [generic_params] ( [where_clause] ';'
                                              | tuple_struct_body [where_clause]
                                              | [where_clause] record_struct_body)

tuple_struct_body ::= '(' <<comma_separated_list tuple_struct_attr>> ')'

tuple_struct_attr ::= outer_attrs [visibility] ty

record_struct_body ::= '{' <<comma_separated_list record_struct_attr>> '}'

record_struct_attr ::= [visibility] ident ':' ty

impl_item ::= [unsafe] impl [generic_params] ty_sum [for ty_sum] [where_clause]
              '{' inner_attr* ([visibility] impl_member)* '}'

impl_member ::= type ident '=' ty_sum ';'
              | const ident ':' ty_sum '=' expr ';'
              | member_fn_item

member_fn_item ::= fn ident [generic_params] member_fn_params [ret_ty] [where_clause] block_expr

member_fn_params ::= '(' ')'
                   | '(' self_param [','] ')'
                   | '(' self_param ',' <<comma_separated_list fn_param>> ')'
                   | '(' <<comma_separated_list fn_param>> ')'

self_param ::= ['&' [lifetime]] [mut] self


////////////////////////////////////////////////////////////////////////
// Part 2: Patterns
////////////////////////////////////////////////////////////////////////

pat ::= '_'
      | '&' pat
      | mut pat
      | '(' <<comma_separated_list pat>> ')'
      | '[' <<comma_separated_list pat>> ']'
      | path '(' <<comma_separated_list pat>> ')'
      | path

pats ::= pat ('|' pat)*

////////////////////////////////////////////////////////////////////////
// Part 3: Types
////////////////////////////////////////////////////////////////////////

ty_sum ::= ty

ty ::= '(' ty ')'
     | '(' <<comma_separated_list ty>> ')'
     | '*' ptr
     | '[' ty_sum ']'
     | '[' ty_sum ';' expr ']'
     | '&' [lifetime] [mut] ty
     | bare_fn
     | type_path

ty_param ::= ident

type_path ::= type_path_segment ("::" type_path_segment)*
type_path_segment ::= ident ['<' <<comma_separated_list ty_sum>> '>']

path ::= ident ("::" ident)*

////////////////////////////////////////////////////////////////////////
// Part 4: Blocks, statements, and expressions
////////////////////////////////////////////////////////////////////////

stmt ::= let pat [':' ty_sum] ['=' expr] ';'
       | statement_like_expr
       | expr ';'


// the root expression rule
expr ::= assign_expr
       | range_expr
       | lor_expr
       | land_expr
       | comp_group
       | bor_expr
       | bxor_expr
       | band_expr
       | shift_group
       | add_group
       | mul_group
       | cast_expr
       | unary_group
       | macro_expr
       | ref_group
       | primary_group


// private rules to define operators with the same priority
private comp_group ::= eq_expr | neq_expr | lt_expr | gt_expr | leq_expr | geq_expr
private shift_group ::= shl_expr | shr_expr
private add_group ::= plus_expr | minus_expr
private mul_group ::= mul_expr | div_expr | mod_expr
private unary_group ::= unary_min_expr | deref_expr | not_expr | borrow_expr
private ref_group ::= ref_expr | array_ref_expr | call_expr
private primary_group ::= struct_expr
                        | simple_ref_expr
                        | literal_expr
                        | paren_expr
                        | tuple_expr
                        | block_expr
                        | lambda_expr
                        | return_expr
                        | if_expr
                        | match_expr


statement_like_expr ::= if_expr | block_expr

// public rules for each expression
assign_expr ::= expr '=' expr { rightAssociative=true }
range_expr ::= expr '..' expr
lor_expr ::= expr '||' expr
land_expr ::= expr '&&' expr

eq_expr ::= expr '==' expr
neq_expr ::= expr '!=' expr
lt_expr ::= expr '<' expr
gt_expr ::= expr '>' expr
leq_expr ::= expr '<=' expr
geq_expr ::= expr '>=' expr

bor_expr ::= expr '|' expr
bxor_expr ::= expr '^' expr

band_expr ::= expr '&' expr

shl_expr ::= expr '<<' expr
shr_expr ::= expr '>>' expr

minus_expr ::= expr '-' expr
plus_expr ::= expr '+' expr

div_expr ::= expr '/' expr
mul_expr ::= expr '*' expr
mod_expr ::= expr '%' expr

cast_expr ::= expr 'as' expr

unary_min_expr ::= '-' expr
deref_expr ::= '*' expr
not_expr ::= '!' expr
borrow_expr ::= '&' [mut] expr

macro_expr ::= ident '!' '(' <<comma_separated_list expr>> ')'

ref_expr ::= expr '.' ident
array_ref_expr ::= expr '[' index_expr ']'
private index_expr ::= expr
call_expr ::= expr '(' [<<comma_separated_list expr>>] ')'

simple_ref_expr ::= path | self
literal_expr ::= lit
paren_expr ::= &('(' expr ')') '(' expr ')'
tuple_expr ::= '(' expr ',' [<<comma_separated_list expr>>] ')'
block_expr ::= '{' stmt* [expr] '}'

lambda_expr ::= '|' [<<comma_separated_list lambda_param>>] '|' [ret_ty] expr
lambda_param ::= pat [":" ty_sum]

struct_expr ::= path '{' <<comma_separated_list struct_field>> ['..' expr]'}'
struct_field ::= ident ':' expr

return_expr ::= return [expr]

if_expr ::= if (let pat '=' expr | expr) block_expr [else block_expr]

match_expr ::= match expr '{'
    (pats [if expr] '=>' (block_expr | expr ','))*
    [pats [if expr] '=>' expr]
'}'

////////////////////////////////////////////////////////////////////////
// Part 5: Macros and misc. rules
////////////////////////////////////////////////////////////////////////

lit ::= lit_byte
      | lit_char
      | lit_integer
      | lit_float
      | lit_string
      | lit_byte_string
      | true
      | false
      | str

meta comma_separated_list ::= <<param>> ( ',' <<param>> ) * [',']
