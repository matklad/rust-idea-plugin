{
  parserClass="org.jetbrains.rust.grammar.RustParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Rust"
  psiImplClassSuffix="Impl"
  psiPackage="org.jetbrains.rust.psi"
  psiImplPackage="org.jetbrains.rust.psi.impl"

  elementTypeHolderClass="org.jetbrains.rust.psi.RustTypes"
  elementTypeClass="org.jetbrains.rust.psi.RustElementType"
  tokenTypeClass="org.jetbrains.rust.parser.RustTokenType"

  tokens=[
    par_left        = "("
    par_right       = ")"
    curly_left      = "{"
    curly_right     = "}"
    bracket_left    = "["
    bracket_right   = "]"
    dot             = "."
    dot_dot         = ".."
    dot_dot_dot     = "..."
    semi            = ";"
    comma           = ","
    bang            = "!"

    white_space='regexp:\s+'
    line_comment='regexp://.*'
    block_comment='regexp:/\*(.|\n)*\*/'
    ident='regexp:\p{Alpha}\w*'

    lit_char="regexp:'.'"
    lit_string="regexp:(\"([^\"\\]|\\.)*\")"
    lit_byte_string='byte_string_lit'
    lit_byte='byte_lit'
    lit_integer='regexp:\d+'
    lit_bool='regexp:true|false'
  ]

   extends(".*expr")=expr
}

////////////////////////////////////////////////////////////////////////
// Part 1: Items and attributes
////////////////////////////////////////////////////////////////////////

rustFile ::= inner_attr* item_with_attrs *

inner_attr ::= '#!' '[' meta_item ']'

outer_attrs ::= outer_attr *

outer_attr ::= '#' '[' meta_item ']'

meta_item ::= ident '=' lit
            | ident '(' <<comma_separated_list meta_item>> ')'
            | ident

item_with_attrs ::= attrs_and_vis item

attrs_and_vis ::= outer_attrs [visibility]

// items that can appear outside of a fn block
private item ::= stmt_item
               | use_item
               | extern_crate_item


extern_crate_item ::= extern crate ident [as ident] ';'
use_item ::= use path_glob ';'

path_glob ::= ident ["::" (path_glob | "*")]
            | '{' [<<comma_separated_list path_item>>] '}'

path_item ::= ident | self

// items that can appear in "stmts"
private stmt_item ::= static_item
                    | const_item
                    | block_item

static_item ::= static [mut] ident ':' ty '=' expr ';'

const_item ::= const ident ':' ty '=' expr ';'

private block_item ::= fn_item | mod_item | struct_item


visibility ::= pub

fn_item ::= fn ident [generic_params] fn_params [ret_ty] [where_clause] block_expr

private fn_params ::= '(' [ <<comma_separated_list fn_param>> ] ')'

fn_param ::= ident ':' ty

private ret_ty ::= '->' ('!' | ty)

generic_params ::= '<' lifetimes '>'

where_clause ::= where

mod_item ::= mod ident ['{' inner_attr* item_with_attrs* '} ']';'

struct_item ::= struct ident [generic_params] ( [where_clause] ';'
                                              | tuple_struct_body [where_clause]
                                              | [where_clause] record_struct_body)

tuple_struct_body ::= '(' <<comma_separated_list tuple_struct_attr>> ')'

tuple_struct_attr ::= outer_attrs [visibility] ty

record_struct_body ::= '{' <<comma_separated_list record_struct_attr>> '}'

record_struct_attr ::= [visibility] ident ':' ty

// ////////////////////////////////////////////////////////////////////////
// // Part 2: Patterns
// ////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////
// // Part 3: Types
// ////////////////////////////////////////////////////////////////////////

ty ::= ident


// ////////////////////////////////////////////////////////////////////////
// // Part 4: Blocks, statements, and expressions
// ////////////////////////////////////////////////////////////////////////

stmt ::= expr ';'


// the root expression rule
expr ::= assign_expr
       | lor_expr
       | land_expr
       | comp_group
       | bor_expr
       | bxor_expr
       | band_expr
       | shift_group
       | add_group
       | mul_group
       | cast_expr
       | unary_group
       | macro_expr
       | ref_group
       | primary_group


// private rules to define operators with the same priority
private comp_group ::= eq_expr | neq_expr | lt_expr | gt_expr | leq_expr | geq_expr
private shift_group ::= shl_expr | shr_expr
private add_group ::= plus_expr | minus_expr
private mul_group ::= mul_expr | div_expr | mod_expr
private unary_group ::= unary_min_expr | deref_expr | not_expr | borrow_expr
private ref_group ::= ref_expr | array_ref_expr | call_expr
private primary_group ::= simple_ref_expr | literal_expr | paren_expr | block_expr

// public rules for each expression
assign_expr ::= expr '=' expr { rightAssociative=true }
lor_expr ::= expr '||' expr
land_expr ::= expr '&&' expr

eq_expr ::= expr '==' expr
neq_expr ::= expr '!=' expr
lt_expr ::= expr '<' expr
gt_expr ::= expr '>' expr
leq_expr ::= expr '<=' expr
geq_expr ::= expr '>=' expr

bor_expr ::= expr '|' expr
bxor_expr ::= expr '^' expr
band_expr ::= expr '&' expr

shl_expr ::= expr '<<' expr
shr_expr ::= expr '>>' expr

minus_expr ::= expr '-' expr
plus_expr ::= expr '+' expr

div_expr ::= expr '/' expr
mul_expr ::= expr '*' expr
mod_expr ::= expr '%' expr

cast_expr ::= expr 'as' expr

unary_min_expr ::= '-' expr
deref_expr ::= '*' expr
not_expr ::= '!' expr
borrow_expr ::= '&' [mut] expr

macro_expr ::= ident '!' '(' expr ')'

ref_expr ::= expr '.' ident
array_ref_expr ::= expr '[' expr ']'
call_expr ::= expr '(' [<<comma_separated_list expr>>] ')'

simple_ref_expr ::= ident
literal_expr ::= lit
paren_expr ::= '(' expr ')'
block_expr ::= '{' stmt* [expr] '}'

////////////////////////////////////////////////////////////////////////
// Part 5: Macros and misc. rules
////////////////////////////////////////////////////////////////////////

lit ::= lit_byte
      | lit_char
      | lit_integer
      | lit_string
      | lit_byte_string
      | true
      | false
      | str

meta comma_separated_list ::= <<param>> ( ',' <<param>> ) * [',']

